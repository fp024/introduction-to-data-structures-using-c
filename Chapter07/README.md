## Chapter 07 큐 (Queue)

### [07-1]  큐의 이해와 ADT 정의
#### 큐(Queue)의 이해
* 선입선출(先入先出, first in, first out)
  * 먼저 들어간 데이터가 먼저 나오는 구조
#### 큐의 ADT 정의
* enqueue 큐에 데이터를 넣는 연산
* dequeue 큐에서 데이터를 꺼내는 연산

##### 큐 자료구조의 ADT
```c
void QueueInit(Queue* pq);
// 큐의 초기화를 진행
// 큐 생성 후 제일 먼저 호출되야함.

int QIsEmpty(Queue* pq);
// 큐가 빈 경우 TRUE(1)을, 그렇지 않은 경우 FALSE(0)을 반환함.

void Enqueue(Queue* pq, Data data);
// 큐에 데이터를 저자한다, 매개변수 data로 전달된 값을 저장함.

Data Dequeue(Queue* pq);
// 저장순서가 가장 앞선 데이터를 삭제함
// 삭제된 데이터는 반환됨.
// 본 함수의 호출을 위해서는 데이터가 하나 이상 존재함이 보장되야함.

Data QPeek(Queue* pq);
// 저장순서가 가장 앞선 데이터를 반환하되 삭제하지 않음.
// 본 함수의 호출을 위해서는 데이터가 하나 이상 존재함이 보장되야한다.

```

### [07-2] 큐의 배열 기반 구현

* 정의
  * F: 큐의머리, R: 큐의 꼬리
* 큐는 뒤로 넣고 앞으로 빼는 자료구조

#### 원형 큐 형태로 구현시 F와 R의 위치만으로 꽉찬경우와 텅 빈 경우를 구분할 수 없음

* 배열을 꽉 채우지 않는다.
* 배열의 길이가 N이라면 데이터가 N-1개 채워졌을 때, 이를 꽉 찬 것으로 간주한다.
  * 반드시 배열의 하나를 비우지 않더라도 방법은 있겠지만. 비우지 않을경우 꽉차거나 비거나의 조건 검사하는 부분이 복잡해질 것 같다.
* F, R의 위치는 계속 회전함, F와 R의 상대적 위치차이를 통해 텅 빈경우와 꽉찬 경우를 구분해야함.

#### 빈 공간 하나를 활용하여 원형큐 구현시...
* enqueue
  * R이 가리키는 위치를 한칸 이동시킨 다음에 R이 가리키는 위치에 데이터 저장

* dequeue
  * F를 한칸 이동 시킨 다음에, F가 가리키는 위치의 데이터를 반환 및 그 위치의 데이터는 소멸

* 큐가 텅빈 상태 
  * F, R이 같은 위치를 가리킴, 그 위치는 비어있음.

* 큐가 꽉찬 상태
  * R이 가리키는 위치의 뒤를 F가 가리킨다.

##### 프로젝트
* CircularQueueLibrary
* CircularQueueMain 


### [07-3] 큐의 연결 리스트 기반 구현

#### 연결 리스트 기반 큐의 헤더파일 정의
* 스택은 push와 pop이 이뤄지는 위치가 같은 반면, 큐는 enqueue와 dequeue가 이뤄지는 위치가 다름.

##### 프로젝트
* ListBaseQueueLibrary
* ListBaseQueueMain

### [07-4] 큐의 활용

* 햄버거 가게 시뮬레이션

  * 점심시간 1시간 동안에는 고객이 15초당 한명씩 주문한다.

  * 종류별 햄버거를 만드는데 걸리는 시간

    * 치즈버거 12초
    * 불고기버거 15초
    * 더블버거 24초

  * 대기실 수용인원에 따른 안정적으로 고객을 수용할 확률

    * 30명: 50%
    * 50명: 70%
    * 100명: 90%
    * 200명: 100%

    

* 기준
  * 점심시간은 1시간이고 그 동안 고객은 15초에 1명씩 주문을 하는 것으로 간주한다.
  * 한 명의 고객은 하나의 버거 만을 주문한다고 가정한다.
  * 주문하는 메뉴에는 가중치를 두지 않는다. 모든 고객은 무작위로 메뉴를 선택한다.
  * 햄버거를 만드는 사람은 1명이다. 그리고 동시에 둘 이상의 버거가 만들어지지 않는다.
  * 주문한 메뉴를 받을 다음 고객은 대기실에서 나와서 대기한다.

##### 프로젝트
* HamburgerSim



### [07-5] 덱(Deque)의 이해와 구현

#### 덱의 이해와 ADT 정의
* 큐는 뒤로 넣고 앞으로 빼는 자료구조
* 덱은 앞으로도 뒤로도 넣을 수 있고, 앞으로도 뒤로도 뺼 수 있는 자료구조
* Deque 
  * double-ended queue

##### 덱 자료구조의 ADT

```c
void DequeInit(Deque* pdeq);
// - 덱의 초기화를 진행한다.
// - 덱 생성 후 제일 먼저 호출되어야 하는 함수이다.

int DQIsEmpty(Deque* pdeq);
// - 덱이 빈 경우 TRUE(1), 그렇지 않은 경우 FALSE(0)을 반환한다.

void DQAddFirst(Deque* pdeq, Data data);
// - 덱의 머리에 데이터를 저장한다. data로 전달된 값을 저장한다.

void DQAddLast(Deque* pdeq, Data data);
// - 덱의 꼬리에 데이터를 저장한다. data로 전달된 값을 저장한다.

Data DQRemoveFirst(Deque* pdeq);
// 덱의 머리에 위치한 데이터를 반환 및 소멸한다.

Data DQRemoveLast(Deque* pdeq);
// 덱의 꼬리에 위치한 데이터를 반환 및 소멸한다.

Data DQGetFirst(Deque* pdeq);
// 덱의 머리에 위치한 데이터를 소멸하지 않고 반환한다.

Data DQGetLast(Deque* pdeq);
// 덱의 꼬리에 위치한 데이터를 소멸하지 않고 반환한다.

```

#### 덱의 구현
##### 프로젝트
* DequeLibrary
* DequeMain


#### 문제 07-1 \[덱을 기반으로 큐를 구현하기]
##### 프로젝트 
* DequeBaseQueue (라이브러리 프로젝트와 메인 프로젝트로 분리하지 않았다.)


### 정오표

* p259 R이 가리키는 위치의 `앞을` F가 가리킨다. -> R이 가리키는 위치의` 뒤를` F가 가리킨다.

